#undef USE_LIGHT_BINDING

// transform object vertices to world-space:
uniform mat4 World : World < string UIWidget="None"; >;

// transform object normals, tangents, & binormals to world-space:
uniform mat4 WorldInverseTranspose : WorldInverseTranspose < string UIWidget="None"; >;

// transform object vertices to view space and project them in perspective:
uniform mat4 MVP : WorldViewProjection < string UIWidget="None"; >;

// provide tranform from "view" or "eye" coords back to world-space:
uniform mat4 ViewInverse : ViewInverse < string UIWidget="None"; >;

//-------------------------------------------------------------------------------------
// DIRECTIONAL LIGHT
uniform vec3 uDirectional0Dir : DIRECTION <
    string UIGroup = "Lights"; 
    string Object = "DirectionalLight0";
    string UIName =  "Lamp 0 Direction";
    string Space = "World";
> = {0.7f,-0.7f,-0.7f};

//-------------------------------------------------------------------------------------
// AMBIENT LIGHT
uniform vec3 ambientColor : AMBIENT <
    string UIGroup = "Lights"; 
	string Object = "AmbientLight0";
    string UIName =  "Ambient Light";
    string UIWidget = "Color";
> = {0.17f,0.17f,0.17f};

//-------------------------------------------------------------------------------------
// DIFFUSE
uniform vec4 diffuseColor
<   
    string UIGroup = "Diffuse";
    string UIName = "Diffuse Color";
	string UIWidget = "Color";
> = {1.0, 1.0, 1.0, 1.0};

uniform texture2D uDiffuseTexture
<
    string UIGroup = "Diffuse";
    string UIName = "Diffuse Texture";
    string ResourceType = "2D";
    int UIOrder = 1001;
>;

uniform sampler2D uDiffuseSampler = sampler_state
{
    Texture = <uDiffuseTexture>;
};

//-------------------------------------------------------------------------------------
// SPECULAR
uniform bool uEnableBlinn
<
    string UIGroup = "Specularity";
    string UIName = "Enable Blinn";
> = false;

uniform vec4 uSpecularColor
<
    string UIGroup = "Specularity";
    string UIName = "Specular Color";
	string UIWidget = "Color";
> = {1.0, 1.0, 1.0, 1.0};

uniform texture2D uSpecularTexture
<
    string UIGroup = "Specularity";
    string UIName = "Specular Texture";
    string ResourceType = "2D";
    int UIOrder = 1001;
>;

uniform sampler2D uSpecularSampler = sampler_state
{
    Texture = <uSpecularTexture>;
};

uniform float uSpecularStrength 
<
    string UIGroup = "Specularity";
	string UIWidget = "slider";
	string UIName = "Specular Strength";
	float UIMin = 0;
	float UIMax = 5;
> = 0.6;

uniform float uSpecularPower 
<
    string UIGroup = "Specularity";
	string UIWidget = "slider";
	string UIName = "Specular highlight size";
	float UIMin = 0;
	float UIMax = 128;
> = 12;

//-------------------------------------------------------------------------------------
// FRESNEL

uniform vec4 uFresnelColor
<
    string UIGroup = "Fresnel";
    string UIName = "Fresnel Color";
	string UIWidget = "Color";
> = {1.0, 1.0, 1.0, 1.0};

uniform float uFresnelPower 
<
    string UIGroup = "Fresnel";
	string UIWidget = "slider";
	string UIName = "Fresnel Strength";
	float UIMin = 0;
	float UIMax = 10;
> = 0.6;

uniform float uFresnelCubemapStrength 
<
    string UIGroup = "Fresnel";
	string UIWidget = "slider";
	string UIName = "Cubemap Strength";
	float UIMin = 0;
	float UIMax = 1;
> = 0.6;

//-------------------------------------------------------------------------------------
// NORMAL MAP

uniform bool uEnableNormalMap
<
    string UIGroup = "Normal Map";
    string UIName = "Enable Normal Map";
> = false;

uniform texture2D uNormalMapTexture
<
    string UIGroup = "Normal Map";
    string UIName = "Normal Map Texture";
    string ResourceType = "2D";
    int UIOrder = 1001;
>;

uniform sampler2D uNormalMapSampler = sampler_state
{
    Texture = <uNormalMapTexture>;
};

uniform float uNormalMapStrength 
<
    string UIGroup = "Normal Map";
	string UIWidget = "slider";
	string UIName = "Normal Map Strength";
	float UIMin = 0;
	float UIMax = 10;
> = 1.0;

//-------------------------------------------------------------------------------------
// CUBEMAP
uniform textureCube uCubemapTexture
<
    string UIName = "Cubemap Texture";
    string ResourceType = "Cube";
    string ResourceName = "../images/damaged_helmet_diffuse_env.dds";
    string UIGroup = "Cubemap";

    int UIOrder = 2001;
>;

uniform samplerCube uCubemapSampler = sampler_state
{
    Texture = <uCubemapTexture>;
    TEXTURE_MIN_FILTER = LINEAR_MIPMAP_LINEAR;
    TEXTURE_MAG_FILTER = LINEAR;
};

uniform float uCubemapStrength
<
    string UIGroup = "Cubemap";
    string UIName = "Cubemap Strength";
    float UIMin = 0.0f;
    float UIMax = 1.0f;
    float UIStep = 0.01f;
    string UIWidget = "slider";
> = 0.0f;

//-------------------------------------------------------------------------------------
// OPACITY
uniform float uOpacityStrength
<
    string UIGroup = "Transparency";
    string UIName = "Opacity Strength";
    float UIMin = 0.0f;
    float UIMax = 1.0f;
    float UIStep = 0.01f;
    string UIWidget = "slider";
> = 1.0f;

//###################################################################
// INPUT/OUTPUT ATTRIBUTES
//
// 
//###################################################################
attribute appdata {
    vec3 aPosition    : POSITION;
    vec2 aUV        : TEXCOORD0;
    vec3 aNormal    : NORMAL;
    vec3 aBinormal : BINORMAL;
    vec3 aTangent : TANGENT;
};

attribute vOutput {
    vec2 outUV : TEXCOORD0;
    vec3 outWorldNormal    : TEXCOORD1;
    vec3 outWorldCameraDir    : TEXCOORD2;
    vec3 outWorldBinormal : TEXCOORD3;
    vec3 outWorldTangent : TEXCOORD4;
};

attribute fOutput 
{
    vec4 colorOut : COLOR0;
}

GLSLShader VS
{
    void main()
    {
        vec3 worldNormal = (WorldInverseTranspose * vec4(aNormal, 0.0)).xyz;
        vec3 worldBinormal = (WorldInverseTranspose * vec4(aBinormal, 0.0)).xyz;
        vec3 worldTangent = (WorldInverseTranspose * vec4(aTangent, 0.0)).xyz;
        vec4 pos = vec4(aPosition.xyz,1);
        vec3 worldPos = (World * pos).xyz;
        vec3 worldCameraPos = ViewInverse[3].xyz;
        vec3 worldCameraDir = worldCameraPos - worldPos;

        outWorldCameraDir = worldCameraDir;
        outWorldNormal = worldNormal;
        outWorldBinormal = worldBinormal;
        outWorldTangent = worldTangent;
        outUV = vec2(aUV.x, 1.0 - aUV.y);

        gl_Position = MVP * pos;
    }
}



GLSLShader FS
{
    // vec4 lit2(float NdotL, float NdotH, float m)
    // {
    //     float spec = (NdotL > 0) ? pow(max(0.0, NdotH), m) : 0;
    //     return vec4(1.0, max(0.0, NdotL), spec, 1.0);
    // }

    float ComputePhong(float specularStrength, vec3 lightDir, vec3 worldNormal, vec3 worldCameraDir, float specularPower)
    {
        float specular = specularStrength * pow(clamp(dot(reflect(-lightDir, worldNormal), worldCameraDir), 0.0, 1.0), specularPower); 

        return specular;
    }

    float ComputeBlinn(float specularStrength, float diffuse, vec3 lightDir, vec3 worldNormal, vec3 worldCameraDir, float specularPower)
    {
        vec3 halfwayDir = normalize(worldCameraDir + lightDir);
        //float specular = specularStrength * pow(max(dot(worldNormal, halfwayDir), 0.0), uSpecularPower);
        float specular = dot(halfwayDir, worldNormal);
        vec4 litV = lit(diffuse, specular, specularPower);
        specular = specularStrength * diffuse * litV.z;

        return specular;
    }

    void main()
    {
        vec3 worldNormal = normalize(outWorldNormal);
        vec3 worldCameraDir = normalize(outWorldCameraDir);
        vec3 reflection = normalize(-reflect(worldCameraDir, worldNormal));
        vec3 lightDir = -normalize(uDirectional0Dir);

        vec4 diffuseTex = texture(uDiffuseSampler, outUV);
        vec4 specularTex = texture(uSpecularSampler, outUV);
        vec4 cubemapTex = texture(uCubemapSampler, reflection);

        //NORMAL MAP
        if (uEnableNormalMap) {
            worldNormal = texture(uNormalMapSampler, outUV).rgb * 2 - 1;
            worldNormal = normalize((worldNormal.x * outWorldTangent * uNormalMapStrength)
			+(worldNormal.y * -outWorldBinormal * uNormalMapStrength)
			+(worldNormal.z * outWorldNormal)).xyz;
        }

        //DIFFUSE LIGHTING
        float diffuse = clamp(dot(outWorldNormal, -uDirectional0Dir), 0.0, 1.0);

        //SPECULAR LIGHTING
        float specular = 0;
        if (uEnableBlinn) {
            specular = ComputeBlinn(uSpecularStrength, diffuse, lightDir, worldNormal, worldCameraDir, uSpecularPower);
        }
        else {
            specular = ComputePhong(uSpecularStrength, lightDir, worldNormal, worldCameraDir, uSpecularPower);
        }

        //FRESNEL
        vec4 fresnel = pow(1 - max(dot(worldCameraDir, worldNormal), 0.0), uFresnelPower) * uFresnelColor;
        fresnel *= mix(vec4(1, 1, 1, 1), cubemapTex, uFresnelCubemapStrength);
        
        //Total Specularity
        vec4 totalSpec;
        if (length(vec3(specularTex.xyz)) > 0) {
            totalSpec = (fresnel * specularTex.r) + (specular * specularTex.g * uSpecularColor);
        }
        else {
            totalSpec = fresnel + (specular * uSpecularColor);
        }
        
        vec4 result;

        //FINAL LIGHTING
        if (length(vec3(diffuseTex.xyz)) > 0) {
            result = (diffuse + vec4(ambientColor.xyz, 1.0)) * (diffuseColor * diffuseTex) + totalSpec; //(specular * uSpecularColor * specularTex.g);
        }
        else {
            result = (diffuse + vec4(ambientColor.xyz, 1.0)) * diffuseColor + totalSpec; //(specular * uSpecularColor * specularTex.g);
        }

        result *= mix(vec4(1, 1, 1, 1), cubemapTex, uCubemapStrength);
        result *= uOpacityStrength;
        
        colorOut.xyz = result.xyz;
        colorOut.a = uOpacityStrength;
    }
}

technique Main
<
    string Transparency = "Transparent";
>
{
    pass p0
    {
        VertexShader (in appdata, out vOutput) = VS;
        PixelShader (in vOutput, out fOutput) = FS;
    }
}