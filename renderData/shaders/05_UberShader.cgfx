//###################################################################
// MATRICES
//
// Matrices coming from application (Maya)
//###################################################################

float4x4 WorldViewProjection     : WorldViewProjection   < string UIWidget = "None"; >;
float4x4 WorldInverseTranspose   : WorldInverseTranspose < string UIWidget = "None"; >;
float4x4 ViewInverse             : ViewInverse           < string UIWidget = "None"; >;
float4x4 World                   : World                 < string UIWidget = "None"; >;

// Maya Description 
string description = "Eat 3D uber shader";

//###################################################################
// PARAMETERS
//
// 
//###################################################################


//Animation time
float time : Time;

//-------------------------------------------------------------------
// DIRECTINAL LIGHT0

float3 lightDirection : Direction
<
	string UIName = "Light Direction";
> = {0.0f, 1.0f, 0.0f};

float3 lightColor : Diffuse
<
	string UIName = "Light Color";
> = {1.0f, 1.0f, 1.0f};

//-------------------------------------------------------------------
// AMBIENT LIGHT

float3 ambientTopColor : Diffuse
<
	string UIName = "Ambient Top Color";
> = {0.15f, 0.15f, 0.15f};

float3 ambientBottomColor : Diffuse
<
	string UIName = "Ambient Bottom Color";
> = {0.0f, 0.0f, 0.0f};

//-------------------------------------------------------------------
// DIFFUSE

float diffuseStrength <
	string UIWidget = "slider";
	string UIName = "Diffuse Strength";
	float UIMin = 0;
	float UIMax = 1;
> = 1;

float3 diffuseColor : Diffuse
<
	string UIName = "Diffuse Color";
> = {1.0f, 1.0f, 1.0f};

//-------------------------------------------------------------------
// SPECULAR

bool blinnEnabled
<
    string UIName = "Enable Blinn";
> = false;

float3 specularColor : Diffuse
<
	string UIName = "Specular Color";
> = {1.0f, 1.0f, 1.0f};

float specularStrength : SPECULAR <
	string UIWidget = "slider";
	string UIName = "Specular Strength";
	float UIMin = 0;
	float UIMax = 5;
> = 0.6;

float specularPower 
<
	string UIWidget = "slider";
	string UIName = "Specular Power";
	float UIMin = 0.1f;
	float UIMax = 128.0f;
	float UIStep = 0.01f;
	
> = 30.0f;

//-------------------------------------------------------------------
// FRESNEL

float3 fresnelColor : Diffuse
<
	string UIName = "Fresnel Color";
> = {1.0f, 1.0f, 1.0f};



float fresnelPower 
<
	string UIWidget = "slider";
	string UIName = "Fresnel Power";
	float UIMin = 0.0f;
	float UIMax = 10.0f;
	float UIStep = 0.01f;
	
> = 3.0f;

//-------------------------------------------------------------------
// SUBSURFACE

float3 subsurfaceColor : Diffuse
<
	string UIName = "Subsurface Color";
> = {0.1f, 0.0f, 0.0f};

float subsurfaceSpread  
<
	string UIWidget = "slider";
	string UIName = "Subsurface Spread";
	float UIMin = 0.0f;
	float UIMax = 1.0f;
	float UIStep = 0.01f;
	
> = 0.0f;

//-------------------------------------------------------------------
// UV MANIPULATION

float2 uvSpeedXY 
<
	string UIName = "UV Animation Speed";
> = {0.0f, 0.0f};

float uvTileX 
<
    string UIWidget = "slider";
	string UIName = "UV Tile X";
    float UIMin = 1;
	float UIMax = 10;
> = 1.0f;

float uvTileY
<
    string UIWidget = "slider";
	string UIName = "UV Tile Y";
    float UIMin = 1;
	float UIMax = 10;
> = 1.0f;

float uvOffsetX
<
    string UIWidget = "slider";
	string UIName = "UV Offset X";
    float UIMin = 0;
	float UIMax = 10;
> = 0.0f;

float uvOffsetY
<
    string UIWidget = "slider";
	string UIName = "UV Offset Y";
    float UIMin = 0;
	float UIMax = 10;
> = 0.0f;

//-------------------------------------------------------------------
// TEXTURES

texture diffuseTexure
<
	string name = "default_color.dds";
	string UIName = "Reflection Texture";
	string TextureType = "Cube";
>;

sampler2D diffuseMap = sampler_state
{
	Texture = <diffuseTexure>;
    AddressU      = Wrap;
    AddressV      = Wrap;
};

texture specTexture
<
    string name = "default_color.dds";
    string UIName = "Specular Texture";
    string TextureType = "2D";
>;

sampler2D specMap = sampler_state
{
    Texture = <specTexture>;
    AddressU      = Wrap;
    AddressV      = Wrap;
};

bool normalMapEnabled
<
    string UIName = "Enable Normal Map";
> = false;

texture normalTexture
<
    string name = "default_color.dds";
    string UIName = "Normal Texture";
    string TextureType = "2D";
>;

sampler2D normalMap = sampler_state
{
    Texture = <normalTexture>;
    AddressU      = Wrap;
    AddressV      = Wrap;
};

float normalMapStrength  
<
	string UIWidget = "slider";
	string UIName = "Normnal Map Strength";
	float UIMin = 0.0f;
	float UIMax = 10.0f;
	float UIStep = 0.01f;
	
> = 1.0f;

//-------------------------------------------------------------------
// CUBEMAP

texture reflectionTexture
<
	string name = "default_cube.dds";
	string UIName = "Reflection Texture";
	string ResourceType = "Cube";
>;

samplerCUBE reflectionMap = sampler_state
{

	Texture = <reflectionTexture>;
	WrapR = ClampToEdge;
	WrapS = ClampToEdge;
	WrapT = ClampToEdge;

};

float reflectionIntensity  
<
	string UIWidget = "slider";
	string UIName = "Reflection Intensity";
	float UIMin = 0.0f;
	float UIMax = 10.0f;
	float UIStep = 0.01f;
	
> = 0.0f;

float reflectionContrast  
<
	string UIWidget = "slider";
	string UIName = "Reflection Contrast";
	float UIMin = 0.0f;
	float UIMax = 10.0f;
	float UIStep = 0.01f;
	
> = 0.0f;

//-------------------------------------------------------------------
// TRANSPARENCY

float opacity  
<
	string UIWidget = "slider";
	string UIName = "Opacity";
	float UIMin = 0.0f;
	float UIMax = 1.0f;
	float UIStep = 0.01f;
	
> = 1.0f;

//###################################################################
// INPUT/OUTPUT STRUCTS
//
// 
//###################################################################

struct appdata {
	float4 position  : POSITION;
	float2 texCoord  : TEXCOORD0;
	float4 normal    : NORMAL;
    float4 binormal  : BINORMAL;
    float4 tangent   : TANGENT;		
};

// output to fragment program
struct vOutput {
        float4 position        : POSITION;
		float2 texCoord		   : TEXCOORD0;
		float3 worldNormal     : TEXCOORD1;
        float3 worldBinormal   : TEXCOORD2;
        float3 worldTangent    : TEXCOORD3;		
		float3 worldCameraDir : TEXCOORD4;
};

//###################################################################
// VERTEX SHADER
//
// 
//###################################################################

vOutput vert(appdata IN)
{
    vOutput output;
	//Compute MVP vertex position
	float4 pos = mul(WorldViewProjection, IN.position);
	//Compute World Space normal
	float3 worldNormal = mul(WorldInverseTranspose, IN.normal);
	//Compute World Space binormal
	float3 worldBinormal = mul(WorldInverseTranspose, IN.binormal);
	//Compute World Space tangent
	float3 worldTangent = mul(WorldInverseTranspose, IN.tangent);
	//Compute World Space vertex position
	float3 worldPos = mul(World, IN.position);
	//Compute World Space camera position
	float3 worldCameraPos = float3(ViewInverse[0].w, ViewInverse[1].w, ViewInverse[2].w);
	//Computee World Space camera direction
	float3 worldCameraDir = worldCameraPos - worldPos;

    output.position = pos;
	output.worldNormal   = worldNormal;
    output.worldBinormal   = worldBinormal;
	output.worldTangent = worldTangent;
	output.worldCameraDir = worldCameraPos - worldPos;
	
	output.texCoord = IN.texCoord;
	
    return output;
}

//###################################################################
// FRAGMENT UTILS
//###################################################################

//PHONG
float3 ComputePhong(float specularStrength, float3 lightDir, float3 worldNormal, float3 worldCameraDir, float specularPower)
{
    //float3 worldCameraDirNorm = normalize(worldCameraDir);
    float3 specular = specularStrength * pow(saturate(dot(reflect(-lightDir, worldNormal), worldCameraDir)), specularPower); 

    return specular;
}

//BLINN
float3 ComputeBlinn(float specularStrength, float diffuse,  float3 lightDir, float3 worldNormal, float3 worldCameraDir, float specularPower)
{
    float3 halfwayDir = normalize(normalize(worldCameraDir) + lightDir);
    float3 specular = dot(halfwayDir, worldNormal);
    //lit -> compute ambient, diffuse and specular lighting coefficients
    float4 litV = lit(diffuse, specular, specularPower);
    specular = specularStrength * diffuse * litV.z;

    return specular;
}

//###################################################################
// FRAGMENT SHADER
//
// 
//###################################################################

float4 frag(vOutput IN) : COLOR
{
	float4 outColor;
	
	float2 uv = IN.texCoord * float2(uvTileX, uvTileY) + float2(uvOffsetX * 0.1, uvOffsetY * 0.1) + (time * uvSpeedXY);
	float3 worldNormal = normalize(IN.worldNormal);

	float3 normalTex = tex2D(normalMap, uv).rgb * 2 - 1;
	if (normalMapEnabled) {
		worldNormal = tex2D(normalMap, uv).rgb * 2 - 1;;
		worldNormal = normalize((worldNormal.x * normalMapStrength * IN.worldTangent)
			+ (worldNormal.y * normalMapStrength * -IN.worldBinormal)
			+ (worldNormal.z * IN.worldNormal));
	}

	// a few vectors used 
	float3 lightDir = normalize(-lightDirection);
	float3 worldCameraDir = normalize(IN.worldCameraDir);
	float3 reflectionVector = - reflect(worldCameraDir, worldNormal);
	float3 cubeMap = texCUBE(reflectionMap, reflectionVector);
	// color and specular maps
	float4 colorMap = tex2D(diffuseMap, uv);
	float4 specularMap  = tex2D(specMap, uv);

	float3 ambientColor = lerp(ambientBottomColor, ambientTopColor, saturate( dot(float3(0,1,0), worldNormal))); 

	// diffuse lighting 
	//float3 diffuse = saturate( (dot(lightDir, worldNormal) * (1-subsurfaceSpread) + subsurfaceSpread) + subsurfaceColor);
	float3 diffuse = saturate( (dot(lightDir, worldNormal) * (1-subsurfaceSpread) + subsurfaceSpread) + subsurfaceColor);
	
	// specularity
	float3 specular;
	if (blinnEnabled) {
		specular = ComputeBlinn(specularStrength, diffuse, lightDir, worldNormal, worldCameraDir, specularPower) * specularColor * specularMap.r;
	}
	else {
		specular = ComputePhong(specularStrength, lightDir, worldNormal, worldCameraDir, specularPower) * specularColor * specularMap.r;
	}
	// rim lighting 
	float3 fresnel = pow(1- saturate(dot(worldCameraDir, worldNormal)), fresnelPower) *fresnelColor * diffuse * lightColor;

	float3 totalSpec = (fresnel + specular) + (pow(cubeMap, reflectionContrast) * reflectionIntensity * specularMap.b );
	
	outColor.rgb = (ambientColor + diffuse)  * (diffuseColor * colorMap.rgb) + totalSpec;
	outColor *= diffuseStrength;
	//outColor.rgb = diffuse ;
	outColor.a = opacity;
	
	return outColor;
}

//###################################################################
// TECHNIQUES
//
// 
//###################################################################

technique Opaque
{
    pass one
    {
		VertexShader = compile vp40 vert();
		PixelShader = compile fp40 frag();
    }
}

technique Transparent 
{
    pass P0 
    {
        DepthTestEnable = true;
		DepthMask       = true;
		CullFaceEnable  = true;
		BlendEnable = true;
		BlendEquation = FuncAdd;
		blendfunc = int2(srcalpha, oneminussrcalpha);
        VertexShader = compile vp40 vert();
        PixelShader = compile fp40 frag();
    }
}
